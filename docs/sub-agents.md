# 子代理（Sub-Agents）

子代理让你把常用的角色、流程或工具组合，封装为可复用的"智能体工具"，在 CLI 中像命令一样调用，或在其它代理内部作为工具被调用。它们通过提供特定于任务的配置，包括自定义的系统提示、工具和单独的上下文窗口，从而实现更高效的问题解决。

## 架构概述

子代理基于 CellJS 框架的依赖注入系统构建，主要组件包括：

### 核心组件
- **CustomAgentProvider**：负责扫描和注册自定义代理
- **AgentConfigResolver**：解析代理配置和文件内容
- **AgentService**：执行代理运行的编排

### 工具集成
子代理可以使用以下工具类型：
- **文件操作**：Read, Write, Edit, MultiEdit, Glob, Grep
- **系统命令**：Bash, BashOutput, KillShell
- **任务管理**：TodoWrite, Task, ExitPlanMode
- **搜索工具**：WebFetch, WebSearch
- **Agent 协调**：Task（用于调用其他子代理）

## 放置位置

支持两级来源，按优先级智能合并（高优先级覆盖低优先级）：
- **项目级**：.codebuddy/agents/（仅在当前项目可用）
- **个人全局**：~/.codebuddy/agents/（所有项目可用）

支持子目录，子目录名会作为来源标签的一部分显示在描述中，便于区分同名代理。

## 文件命名与识别

- 每个 .md 文件即一个子代理，例如: .codebuddy/agents/test.md 会注册为名称 test 的代理
- 名称默认取文件名（去除 .md 扩展名），也可在 Frontmatter 中通过 name 指定
- 代理名称应该简短且具有描述性，便于在工具列表中识别

## Frontmatter 元数据

在 Markdown 顶部可使用 YAML Frontmatter 配置元数据：

```markdown
---
name: "my-agent"
description: "负责代码审阅与建议"
model: "gpt-4o"
tools: "Read,Write,Edit,Bash,TodoWrite,ExitPlanMode"
color: "#4A90E2"
---

这里是该子代理的系统指令与工作说明……
```

### 字段说明
- **name**：可选。覆盖默认名称（文件名）
- **description**：可选。简要描述。系统会自动附加来源标签 (project|user 以及子目录路径)
- **model**：可选。当前实现会解析但不强制使用，按产品配置可能由上层决定
- **tools**：可选。逗号分隔列表。当未指定时，会继承当前默认代理的工具集合。内部会自动移除 task 工具，子代理无法使用 Task 工具
- **color**：可选。指定代理在界面中显示的颜色标识（如 "#FF5733"）。如未指定，系统会基于代理名称自动生成一致的颜色

### 可用工具列表
子代理可以使用的工具包括：
- `Read` - 读取文件
- `Write` - 写入文件
- `Edit` - 编辑文件
- `MultiEdit` - 多文件编辑
- `Glob` - 文件模式匹配
- `Grep` - 内容搜索
- `Bash` - 执行命令
- `BashOutput` - 查看命令输出
- `KillShell` - 终止命令
- `TodoWrite` - 任务管理
- `ExitPlanMode` - 退出计划模式

- `WebFetch` - 网页抓取
- `WebSearch` - 网页搜索

## 指令内容

Frontmatter 之后的正文即为该子代理的"系统/工作指令"，在执行时会作为该代理的 instructions 传入。

### 指令编写最佳实践
1. **明确角色定义**：清楚说明代理的职责和专长领域
2. **定义输入输出**：说明期望的输入格式和产生的输出类型
3. **步骤清晰**：提供清晰的工作流程和决策逻辑
4. **错误处理**：包含错误处理机制和回退策略
5. **工具使用指导**：说明何时及如何使用特定的工具

## 作为工具使用

- 子代理会被标记为 asTool: true，可在其它工作流或代理中被当作工具调用
- 系统会自动打上标签：cli、custom，方便在列表中过滤
- 子代理无法使用 `Task` 工具调用其他子代理，这是为了防止无限递归调用和保持架构简洁

## 来源标签示例

- (project)：来自项目根的 .codebuddy/agents 目录
- (project:review)：来自 .codebuddy/agents/review/ 子目录
- (user)：来自 ~/.codebuddy/agents 目录
- (user:experiments:lint)：来自 ~/.codebuddy/agents/experiments/lint/ 子目录

该标签会自动拼接到 description 末尾，例如：代码审阅 (project:review)

## 编写建议

### 命名规范
- 使用短横线分隔的小写字母（如：code-reviewer）
- 名称应具有描述性且易于识别
- 避免使用过于通用的名称

### 目录组织
- 按功能域组织子目录（如：review/, test/, deploy/）
- 项目特定代理放在项目级目录
- 通用代理放在用户级目录

### 工具声明
- 显式声明依赖的工具，避免隐含依赖
- 仅声明实际需要的工具，减少权限需求
- 考虑工具的安全性和权限要求

## 管理界面

使用 `/agents` 斜杠命令可以打开可视化的代理管理界面，支持：

- **创建代理**：通过自然语言描述自动生成代理配置
- **智能配置**：AI 自动生成系统提示词和使用场景描述
- **位置选择**：可选择保存到项目级或用户级目录
- **删除管理**：安全删除不需要的代理
- **实时预览**：创建前可预览完整的代理配置

## 调试与故障排除

### 常见问题
- **代理未显示**：检查文件路径和命名是否正确
- **工具不可用**：确认工具名称拼写正确且已声明
- **权限错误**：某些工具可能需要特定权限模式

### 调试命令
- 使用 `DEBUG=codebuddy:* codebuddy` 查看详细日志
- 检查代理注册日志以确认配置是否正确加载

## 高级用法

### 代理协作
子代理可以相互调用，实现复杂的多代理工作流：
```
主要代理 → 子代理A → 子代理B → 子代理C
```

### 工具链组合
通过组合不同的工具，子代理可以实现复杂的工作流：
- 代码分析：Read + Grep + Edit
- 项目构建：Bash + TodoWrite + WebFetch
- 自动化测试：Bash + Task + ExitPlanMode

## 示例配置

### 代码审查代理
```markdown
---
name: "code-reviewer"
description: "自动化代码审查和代码质量检查"
tools: "Read,Grep,Edit,TodoWrite"
color: "#2E8B57"
---

你是一个专业的代码审查助手，专门负责审查代码质量、发现潜在问题并提供改进建议。

## 工作流程
1. 读取指定文件或目录的代码
2. 分析代码结构和逻辑
3. 检查代码质量和最佳实践
4. 提供具体的改进建议
5. 创建待办事项跟踪需要修复的问题

## 输出格式
- 使用 markdown 格式输出审查结果
- 包含问题描述、位置和修复建议
- 按优先级对问题进行排序
```

## 工具限制说明

### Task 工具限制
子代理配置中自动移除 Task 工具，这是系统的设计选择：

- **安全考虑**：防止无限递归调用和循环依赖
- **架构简洁**：保持子代理职责单一化，专注于具体任务执行
- **权限控制**：避免子代理间的复杂权限传递

### 替代协作方案
虽然子代理不能直接相互调用，但可以通过以下方式实现协作：

1. **主代理协调**：由主代理负责调用多个子代理，协调工作流
2. **工具组合**：通过 Bash、WebFetch、Grep 等工具组合实现复杂功能
3. **参数化设计**：子代理支持参数配置，适应不同使用场景

## 常见问题

- **没有 tools 会怎样？**会继承默认代理的工具集合
- **同名文件如何区分？**通过 description 中的来源标签区分
- **可以嵌套目录吗？**可以，目录路径将体现在来源标签中
- **如何快速创建代理？**使用 `/agents` 命令进入管理界面，输入自然语言描述即可
- **子代理可以调用其他子代理吗？**不可以，系统会自动移除 Task 工具
- **工具权限如何控制？**子代理的权限继承自调用它的主代理权限设置
